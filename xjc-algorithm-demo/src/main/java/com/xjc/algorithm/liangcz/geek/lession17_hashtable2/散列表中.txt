# 如何打造一个工业级别的散列表?
散列表的查询效率不能笼统的说成是O(1)，它跟散列函数、装载因子、散列冲突等有关系。
极端的情况下，如果恶意的攻击者使用精心构造的数据，会使数据都落在一个槽位上，导致查询效率急剧下降
时间复杂度从O(1)退化成O(n)。
因此我们需要设计工业级的散列表，避免散列攻击
# 设计一个好的散列函数
1、散列函数不能设计的太复杂，否则会影响性能。
2、散列函数设计应该考虑关键值的长度、大小、特点、分布。
3、散列函数设计方法有数据分析法、直接寻址法、平方取中法、折叠法、随机数法。
# 装载因子过大
1、装载因子过大会导致数据落在同一个槽位可能性增大，散列冲突可能性增大
2、装载因子达到一定限度，要自动扩容。
# 如何避免扩容造成的长时间卡顿，客户体验不好
1、在装载因子达到某个值的时候，先数组扩容
2、新数据插入，先插入到新的散列表，再从老的散列表取一个移一个数到新的散列表
# LinkedHashMap 和 ThreadLocalMap
1、LinkedHashMap 使用开放寻址法，ThreadLocalMap使用链表法。
2、两者各有优缺点，开放寻址法可以很好利用cpu缓存，提高速度，序列化好，但是数据过多会造成散列冲突。
链表法，序列化慢，但是能更好处理散列冲突，装更多数据，不影响查询
3、总结来说，ThreadLocalMap使用开放寻址法是因为，序列化快、数据量小、速度要求快
   LinkedHashMap 能装更多数据，散列冲突可能性低
# hashMap 实现
1、合理设置初始容量，避免扩容。hashMap的初始容量是16。
2、装载因子0.75
3、合理设置散列函数
4、JDK1.8使用红黑树。当链表数据量超过8的使用，避免过长拉链，使用红黑树。小于8，使用链表。
