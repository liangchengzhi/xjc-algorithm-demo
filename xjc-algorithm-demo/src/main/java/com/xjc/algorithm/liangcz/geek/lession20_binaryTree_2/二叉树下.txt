# 二叉树下（有了散列表，为什么还需要二叉树？）
# 二叉查找树
对于任意一个节点，左边节点的值都比这个节点值小，
右边任意节点都比这个节点值大
# 二叉查找树的查找、插入、删除
# 查找
先查找一个节点，如果值比该节点小，则找左子树；如果值比该节点大，则找右子树。
# 插入
与节点比较，如果节点比该值小，如果子节点为空则插入左子节点，
 否则继续遍历左子树；
与节点比较，如果节点比该值大，如果子节点为空则插入右子节点，
否则继续遍历右子树
# 删除
1、如果要删除的节点，没有子节点，则将父节点指向空
2、如果要删除的节点，只有左子节点或者只有右子节点，
       则将父节点指向该节点子节点
3、如果删除的节点有左子节点和右子节点，
       则在右子树中寻找合适的节点，替换到原节点位置
# 卫星字段
我们在实际开发中，把构建树的整形字段叫卫星字段
# 如何解决key值冲突，也就是相同key值存不同的值？
1、使用链表或者数组法
2、如果有相同的数据，把它当成大于该节点，继续向右插入
   此时，查找和插入也要对应注意，找到后还要继续查找
3、标记删除法
# 时间复杂度
二叉树两个极端：
1、退化为链表，查找复杂度为O(n)
2、完全二叉树或者满二叉树O(height)，跟高度成正比。
3、完全二叉树高度是log2n
4、平衡二叉树的查找、插入、删除时间复杂度都是logn

# 为什么有散列表还需要二叉树？
散列表的复杂度是O(1)，而二叉树的最好复杂度是logn
1、散列表是无序的，而二叉树只需要中序遍历就可以输出有序的数列
2、散列表扩容不稳定，还需要重新计算哈希，时间复杂度可能突然升高。
      二叉树比较稳定都是logn
3、散列表的O(1)是笼统说的，如果哈希冲突厉害，可能比logn大
4、二叉树比较简单，而散列表需要考虑扩容、缩容、散列函数等等
5、散列表的装载因子不能有限制，否则影响效率，会造成一定空间的浪费。




